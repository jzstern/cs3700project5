#!/usr/bin/env python

import sys, socket, select, time, json, random

class KVStore:
    def __init__(self, id, replicas):
        # Socket connection
        self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
        # Instance ID number
        self.id = id
        # The ID numbers of all the other replicas
        self.replicas = replicas
        # Message buffer
        self.messages = []
        # Timeout in milliseconds
        self.timeout = random.randint(250, 350) / float(1000)
        # Timeout to be used during a split vote
        self.election_timeout = random.randint(50, 125) / float(1000)
        # Time between heartbeat messages (in seconds)
        self.heartbeat_timeout = .04 #self.timeout / 3
        # Time I sent the last heartbeat message
        self.last_heartbeat_sent = time.time()
        # The current election term across all replicas
        self.term = 0
        # A list of dictionaries containing a command, the term it was added during,
        # and the # of acks received for the entry.
        self.log = []
        # Dict containing key value pairs as requested by the client
        self.key_store = {}
        # Index of the last thing I committed to my log
        self.commit_index = 0
        # Index of the last thing applied to the state machine
        self.last_applied = 0
        # Dict { replica_id: next_index } representing the index of the next log entry to send to each replica
        self.next_index = {}
        # List of indexes of the highest entry known to be replicated in the keystore of each replica
        self.match_index = []
        # Needs to be one of the following: follower, candidate, leader
        self.state = 'follower'
        # Counter for the number of messages sent
        self.MID = 0
        # List of replica IDs of those who have voted for me to be elected
        self.votes = []
        # ID of our current leader
        self.leader = 'FFFF'
        # Time we last heard a message from the leader
        self.last_leader_msg = time.time()
        # Time that the most recent election I was a candidate for started
        self.election_start_time = ''

        # Connect to the network. All messages to/from other replicas and clients will occur over this socket
        self.sock.connect(self.id)

    # just for debug prints so we can easily turn printing on and off
    def my_print(self, string):
        #print "{0}     {1}".format(self.id, string)
        return

    # init election process by changing state to candidate, incrementing term and sending elect msgs to replicas
    def request_vote(self):
        self.my_print("requesting votes, term {0}".format(self.term))
        # wipe out any old votes before starting a new election
        self.leader = 'FFFF'
        self.votes = [self.id] # vote for urself tho
        self.state = 'candidate'
        self.term += 1
        for replica in self.replicas:
            self.send_message(replica, 'req_vote')
        self.election_start_time = time.time()
        return

    # maybe cast a vote for the replica with id ID
    # last_index: the index of the candidate's last log entry
    # last_term: the term of the candidate's last log entry
    def cast_vote(self, ID, term, last_index, last_term):
        # we only vote for a candidate if their log is more up to date than ours.
        # we consider it more up to date if their last log entry has a higher term
        # than our last long entry OR if the terms are equal, if their log is at least
        # as long as ours
        if (last_index == 0 and last_term == 0) or (last_term > self.log[len(self.log) - 1]['term']) or ((last_term == self.log[len(self.log) - 1]['term']) and (last_index >= len(self.log))): 
            self.my_print("casting vote for {0}, term {1}".format(ID, self.term))
            self.term = term
            self.send_message(ID, 'cast_vote')
            self.last_leader_msg = time.time()
        else:
            self.my_print("Did NOT cast a vote.")
        return

    def handle_vote(self, src):
        # if the sender has not voted for me yet, add the vote to my list of votes
        if src not in self.votes:
            self.votes.append(str(src))
            self.my_print("{0} voted for me".format(src))

        # if majority voted for me
        if len(self.votes) > (len(self.replicas) / 2): # > not >= bc self.votes includes candidate
            self.my_print("I'M THE BOWSS BITCEHESZZZZ, term {0}".format(self.term))
            # we are the leader!
            self.leader = self.id
            self.state = 'leader'
            self.commit_index = len(self.log)

            # Update everyone's next_index to match my last logged + 1
            for replica in self.replicas:
                self.next_index[replica] = len(self.log) + 1

            # Tell everyone I'm the BOSS
            self.send_heartbeat()

        self.my_print("{0} voted for me".format(self.votes))
        return

    # given a heartbeat message, determines if we have a new leader & updates
    # accordingly
    def check_leadership(self, msg_source, msg_leader, msg_term, msg_type, leader_commit_index):
        # If we receive a message with a higher term or we get a heartbeat from a different leader than our own....
        if ((self.state == 'follower') or (self.state == 'candidate' and (msg_term >= self.term or leader_commit_index >= self.commit_index))):

            if self.leader == 'FFFF':
                self.my_print("Going to change my leader to {0}".format(msg_source))
            # ... make that replica our leader
            self.leader = msg_source

            # Update our term and state
            self.term = msg_term
            self.state = 'follower'

            #self.my_print("Updated our leader: {0}".format(self.leader))
        return

    def send_message(self, dest, type, value={}, MID=''):
        """
        Sends a message over the socket to the dst with the given parameters
        :param dst: Message destination
        :param type: One of the following
            get: Read request from client
            put: Update store with given value from client
            redirect: Forward put or get request to leader
            noop:
            req_vote: For candidates to request votes from replicas
            cast_vote: Send a vote for a candidate to that candidate
        """

        # Optional argument workaround
        if MID == '':
            MID = self.id + str(self.MID)

        msg = {
                'src': self.id,
                'dst': dest,
                'leader': self.leader,
                'type': type,
                'MID': MID,
                'term': self.term
            }

        # Heartbeat message
        if type == 'append_entries':
            prev_log_index = self.next_index[dest] - 1

            # If it's a blank heartbeat message
            if len(self.log) == 0:
                msg.update({
                    'entries': [],
                    'prev_log_index': prev_log_index,
                    'prev_log_term': '',
                    'leader_commit_index': self.commit_index,
                    'leader_last_applied': self.last_applied
                })
            # If there are entries to add
            # If we have more than 10 entries to send them, just send 10.
            elif len(self.log) - prev_log_index > 75:
                msg.update({
                    'entries': self.log[prev_log_index:prev_log_index + 75],
                    'prev_log_index': prev_log_index,
                    'prev_log_term': self.log[prev_log_index - 1]['term'],
                    'leader_commit_index': self.commit_index,
                    'leader_last_applied': self.last_applied
                })
            else:
                msg.update({
                    'entries': self.log[prev_log_index:],  # sus but shorthand
                    'prev_log_index': prev_log_index,
                    'prev_log_term': self.log[prev_log_index - 1]['term'],
                    'leader_commit_index': self.commit_index,
                    'leader_last_applied': self.last_applied
                })

        elif type == 'ok':
            msg.update({'value': value})

        elif type == 'ack':
            msg.update(value)
        
        elif type == 'req_vote':
            # if we are sending a vote request, the voters will need to know
            # the index and term of our last log entry to determine if we're
            # more up to date than they are
            if len(self.log) > 0:
                msg.update({
                    'last_index': len(self.log),
                    'last_term': self.log[len(self.log) - 1]['term']
                })
            else:
                msg.update({
                    'last_index': 0, 
                    'last_term': 0
                })

        self.MID += 1
        #if msg['src'] not in replicas:
        self.my_print("SENDING MESSAGE")
        self.my_print(json.dumps(msg))
        self.sock.send(json.dumps(msg))
        return

    def send_heartbeat(self):
        for replica in self.replicas:
            self.send_message(replica, 'append_entries')

        self.last_heartbeat_sent = time.time()

    def handle_heartbeat(self, entries, prev_log_index, prev_log_term, term, leader_commit_index, leader_last_applied):
        self.last_leader_msg = time.time()

        if len(entries) > 0:
            self.update_log(entries, prev_log_index, prev_log_term, term, leader_commit_index)
            self.update_keystore(leader_last_applied)
        return

    def handle_ack(self, src, identical_logs, replica_commit_index):
        # If a replica's log isn't identical to mine (leader's)...
        if not identical_logs:
            # ... decrement their next_index
            self.next_index[src] -= 1
            #self.send_message(src, 'append_entries')
        else:
            # ... but if they match, update their next_index
            self.next_index[src] = replica_commit_index + 1

            # see if they committed the entries we wanna apply so we can 
            # increment our ack counts for the entries
            index_to_apply = self.last_applied + 1 # index of next entry we wanna apply
            while True:
                # if the index is greater than their commit index, they haven't committed
                # the entry. we cannot increment any acks, so break out of the loop
                if index_to_apply > replica_commit_index:
                    break

                if len(self.log) >= index_to_apply:
                    # if we got here, the index to apply <= replica's commit index
                    # this means they committed what we wanna apply, so let's add an ack
                    # to its count and check the next thing we wanna apply.
                    self.log[index_to_apply - 1]['ack'] += 1
                    index_to_apply += 1
                else:
                    break
            
            while True:
                if len(self.log) > self.last_applied:
                    # the entry to apply to our store
                    entry = self.log[self.last_applied]
                else:
                    break
                # if we do not have enough acks to apply this, exit the loop
                if entry['ack'] < (len(self.replicas) / 2): # dont use +1 bc assume leader acked
                    break
                self.key_store[entry['key']] = entry['value']
                self.last_applied += 1
                self.send_message(entry['client'], 'ok', entry['value'], entry['MID'])
        return

    def get(self, client, key, MID):
        if key in self.key_store:
            value = self.key_store[key]
        else:
            value = ''
        self.send_message(client, 'ok', value, MID)
        self.my_print('Getting value: ' + str(value))
        return

    def put(self, client, key, value, MID):
        # TODO: WHEREVER WE ADD TO LOG - MAKE SURE UNIQUE MID
        self.log.append({
            'key': key,
            'value': value,
            'term': self.term,
            'client': client,
            'MID': MID,
            'ack': 0
        })
        self.commit_index += 1
        #self.my_print('I just logged ' + str(self.log[len(self.log) - 1]))
        return

    def update_log(self, entries, prev_log_index, prev_log_term, term, leader_commit_index):
        identical_logs = True

        # Reply false if the heartbeat term is less than our term (1)
        if term < self.term:
            identical_logs = False
            self.send_message(self.leader, 'ack', {'identical_logs': identical_logs, 'commit_index': self.commit_index})
            self.my_print('FALSE - inconsistent logs ')
            return

        # If our log is empty...
        if len(self.log) == 0:
            for entry in entries:
                # ... add the entries from our leader to our log
                self.log.append({
                    'key': entry['key'],
                    'value': entry['value'],
                    'term': entry['term'],
                    'client': entry['client'],
                    'MID': entry['MID'],
                    'ack': entry['ack']
                })
                #self.my_print('I just logged ' + str(entry['value']))

        # If our prev_log_index is in range of our current log... (2)
        elif prev_log_index <= len(self.log):
            # ... and the terms match up... (2)
            if self.log[prev_log_index - 1]['term'] == prev_log_term:
                # ... add all new entries to log (4)
                # (3)
                i = 0

                for entry in entries:
                    # If we are trying to add an entry with the same index as an existing entry but different term...
                    if len(self.log) > prev_log_index + i:
                        if self.log[prev_log_index + i]['term'] != entry['term']:
                            # ... delete that entry and everything following
                            self.log = self.log[:prev_log_index + i]
                            #self.my_print('I just deleted some stuff from my log')
                            break
                    # Otherwise, add it to our log
                    else:
                        self.log.append({
                            'key': entry['key'],
                            'value': entry['value'],
                            'term': entry['term'],
                            'client': entry['client'],
                            'MID': entry['MID'],
                            'ack': entry['ack']
                        })
                        #self.my_print('I just logged ' + str(entry['value']))

                    i += 1

            # If the terms don't match up, then our logs are fucked
            else:
                identical_logs = False
                self.my_print('FALSE - inconsistent logs (they fucked)')

        # Update our commit_index to be the length of our current log
        self.commit_index = len(self.log)

        # (5)
        if leader_commit_index > self.commit_index:
            self.commit_index = min(leader_commit_index, len(self.log))

        self.send_message(
            self.leader,
            'ack',
            {'identical_logs': identical_logs, 'commit_index': self.commit_index}
        )
        return

    def update_keystore(self, leader_last_applied):
        if leader_last_applied > self.last_applied and len(self.log) > self.last_applied:
            for entry in self.log[self.last_applied - 1:]: #TODO : should this be -1??? idts...
                self.key_store[entry['key']] = entry['value']
                self.last_applied += 1
                #self.my_print('I just applied ' + str(entry['value']))
        return

    def receive_messages(self):
        msg_raw = self.sock.recv(32768)

        if len(msg_raw) == 0:
           return

        self.my_print("RECEIVED A MESSAGE")
        self.my_print('     ' + msg_raw)
        msg = json.loads(msg_raw)
        self.messages.append(msg)
        return

    def handle_messages(self):
        while len(self.messages) > 0:
            msg = self.messages.pop(0)

            if 'term' in msg and msg['term'] > self.term:
                 # ... make that replica our leader
                self.leader = msg['src']

                # Update our term and state
                self.term = msg['term']
                self.state = 'follower'

            # If I am the leader...
            if self.state == 'leader':
                if msg['type'] == 'get':
                    self.get(msg['src'], msg['key'], msg['MID'])
                    # TODO ; if a get() fails, send a 'fail'

                elif msg['type'] == 'put':
                    # TODO ; if a put() fails, send a 'fail' and retry
                    self.put(msg['src'], msg['key'], msg['value'], msg['MID'])

                elif msg['type'] == 'ack':
                    self.handle_ack(msg['src'], msg['identical_logs'], msg['commit_index'])

            # We are not the leader but...
            else:
                # ... we got a heartbeat message
                if msg['type'] == 'append_entries':
                    self.check_leadership(msg['src'], msg['leader'], msg['term'], msg['type'], msg['leader_commit_index'])
                    self.handle_heartbeat(
                        msg['entries'],
                        msg['prev_log_index'],
                        msg['prev_log_term'],
                        msg['term'],
                        msg['leader_commit_index'],
                        msg['leader_last_applied']
                    )

                # ... we received a get() or put() request...
                elif msg['type'] in ['get', 'put']:
                    # ...if we have a leader...
                    if self.leader != 'FFFF':
                        # ... redirect it to the leader
                        self.send_message(msg['src'], 'redirect', {}, msg['MID'])
                    # ...if we don't have a leader...
                    else:
                        # ... send a type "fail" message
                        self.send_message(msg['src'], 'fail', {}, msg['MID'])

                # ... or if we are asked to cast a vote
                elif msg['type'] == 'req_vote':
                    self.my_print("received a vote request!")
                    if self.state == 'follower':
                        self.leader = 'FFFF'
                        #if msg['term'] > self.term:
                        self.cast_vote(msg['src'], msg['term'], msg['last_index'], msg['last_term'])

                # ... or if someone casts a vote for us
                elif msg['type'] == 'cast_vote' and self.state == 'candidate':
                    self.my_print("got a vote from {0} woohoo lets handle it!".format(msg['src']))
                    self.handle_vote(msg['src'])
        return
    
    def listen(self):
        while True:
            ready = select.select([self.sock], [], [], 0.01)[0]
            if self.sock in ready:
                self.receive_messages()

            self.handle_messages()

            clock = time.time()

            # If I am a follower and I haven't heard from the leader for the length of timeout, try to elect myself
            if self.state == 'follower' and clock - self.last_leader_msg >= self.timeout:
                self.my_print("Haven't heard from our leader, timeout")
                self.request_vote()

            # If an election lasts longer than our election timeout, try to re-elect myself
            # "split vote"
            if self.state == 'candidate' and clock - self.election_start_time >= self.election_timeout:
                self.my_print("SPLIT VOTE TIMEOUT")
                self.my_print("split vote timeout " + str(clock - self.election_start_time))
                self.request_vote()

            # If I haven't sent a heartbeat in awhile, send one
            if self.state == 'leader' and clock - self.last_heartbeat_sent >= self.heartbeat_timeout:
                self.send_heartbeat()

        return

if __name__ == "__main__":
    init_id = sys.argv[1]
    init_replica_ids = sys.argv[2:]

    db = KVStore(init_id, init_replica_ids)
    db.listen()
