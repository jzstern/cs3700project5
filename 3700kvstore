#!/usr/bin/env python

import sys, socket, select, time, json, random

class KVStore:
    def __init__(self, id, replicas):
        # Socket connection
        self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
        # Message buffer
        self.id = id
        # The ID numbers of all the other replicas
        self.replicas = replicas
        self.messages = []
        # Timeout in milliseconds
        self.timeout = random.randint(150, 300) / float(1000)
        # Timeout to be used during a split vote
        self.election_timeout = random.randint(50, 125) / float(1000)
        # Time between heartbeat messages (in seconds)
        self.heartbeat_timeout = .1
        # Time I sent the last heartbeat message
        self.last_heartbeat_sent = time.time()
        # Instance ID number
        # The current election term across all replicas
        self.term = 0
        # A list of dictionaries containing a command, the term it was called, and a log index
        self.log = []
        # Dict containing key value pairs as requested by the client
        self.key_store = {}
        # Index of the last thing I committed to my log
        self.commit_index = 0
        # Index of the last thing applied to the state machine
        self.last_applied = 0
        # Number of replicas that have an updated to the next log entry we want to commit
        self.ack_count = 0
        # Dict { replica_id: next_index } representing the index of the next log entry to send to each replica
        self.next_index = {}
        # List of indexes of the highest entry known to be replicated in the keystore of each replica
        self.match_index = []
        # Needs to be one of the following: follower, candidate, leader
        self.state = 'follower'
        # Counter for the number of messages sent
        self.MID = 0
        # List of replica IDs of those who have voted for me to be elected
        self.votes = []
        # ID of our current leader
        self.leader = 'FFFF'
        # Time we last heard a message from the leader
        self.last_leader_msg = time.time()
        # Time that the most recent election I was a candidate for started
        self.election_start_time = ''

        # Connect to the network. All messages to/from other replicas and clients will occur over this socket
        self.sock.connect(self.id)

    # init election process by changing state to candidate, incrementing term and sending elect msgs to replicas
    def request_vote(self):
        print "{0}     requesting votes, term {1}".format(self.id, self.term)
        # wipe out any old votes before starting a new election
        self.leader = 'FFFF'
        self.votes = [self.id] # vote for urself tho
        self.state = 'candidate'
        self.term += 1
        self.send_message('FFFF', 'req_vote')
        self.election_start_time = time.time()
        return

    def cast_vote(self, ID, term):
        print "{0}     casting vote for {1}, term {2}".format(self.id, ID, self.term)
        self.term = term
        self.leader = 'FFFF'
        self.send_message(ID, 'cast_vote')
        self.last_leader_msg = time.time()
        return

    def handle_vote(self, src):
        # if the sender has not voted for me yet, add the vote to my list of votes
        if src not in self.votes:
            self.votes.append(str(src))
            print "{0}     {1} voted for me".format(self.id, src)

        # if majority voted for me
        if len(self.votes) > (len(self.replicas) / 2) + 1:
            print "{0}     I'M THE BOWSS BITCEHESZZZZ, term {1}".format(self.id, self.term)
            # we are the leader!
            self.leader = self.id
            self.state = 'leader'
            self.ack_count = 0
            self.commit_index = 0

            # Update everyone's next_index to match my last logged + 1
            for replica in self.replicas:
                self.next_index[replica] = len(self.log) + 1

            # Tell everyone I'm the BOSS
            self.send_heartbeat()

        print "{0}     voted for me: {1}".format(self.id, self.votes)
        return

    def check_leadership(self, msg_source, msg_leader, msg_term, msg_type):
        # If we receive a message with a higher term or we get a heartbeat from a different leader than our own....
        if msg_source == msg_leader and msg_term > self.term or (msg_type == 'append_entries' and msg_leader != self.leader):
            # ... make that replica our leader
            self.leader = msg_source

            # Update our term and state
            self.term = msg_term
            self.state = 'follower'

            print "{0}     Updated our leader: {1}".format(self.id, self.leader)
        return

    def send_message(self, dest, type, value={}, MID=''):
        """
        Sends a message over the socket to the dst with the given parameters
        :param dst: Message destination
        :param type: One of the following
            get: Read request from client
            put: Update store with given value from client
            redirect: Forward put or get request to leader
            noop:
            req_vote: For candidates to request votes from replicas
            cast_vote: Send a vote for a candidate to that candidate
        """

        # Optional argument workaround
        if MID == '':
            MID = self.id + str(self.MID)

        msg = {
                'src': self.id,
                'dst': dest,
                'leader': self.leader,
                'type': type,
                'MID': MID,
                'term': self.term
            }

        # Heartbeat message
        if type == 'append_entries':
            prev_log_index = self.next_index[dest] - 1

            # If it's a blank heartbeat message
            if len(self.log) == 0:
                msg.update({
                    'entries': [],
                    'prev_log_index': prev_log_index,
                    'prev_log_term': '',                                            # TODO idk
                    'leader_commit_index': self.commit_index,
                    'leader_last_applied': self.last_applied
                })
            # If there are entries to add
            else:
                msg.update({
                    'entries': self.log[prev_log_index:],  # sus but shorthand
                    'prev_log_index': prev_log_index,
                    'prev_log_term': self.log[prev_log_index - 1]['term'],          # TODO ; do we need a -1 here???
                    'leader_commit_index': self.commit_index,
                    'leader_last_applied': self.last_applied
                })

        elif type == 'ok':
            msg.update({'value': value})

        elif type == 'ack':
            msg.update(value)

        self.MID += 1
        #print json.dumps(msg)
        self.sock.send(json.dumps(msg))
        return

    def send_heartbeat(self):
        for replica in self.replicas:
            self.send_message(replica, 'append_entries')

        self.last_heartbeat_sent = time.time()

    def handle_heartbeat(self, entries, prev_log_index, prev_log_term, term, leader_commit_index, leader_last_applied):
        self.last_leader_msg = time.time()

        if len(entries) > 0:
            self.update_log(entries, prev_log_index, prev_log_term, term, leader_commit_index)
            self.update_keystore(leader_last_applied)
        return

    def handle_ack(self, src, identical_logs, replica_commit_index):
        # If a replica's log isn't identical to mine (leader's)...
        if not identical_logs:
            # ... decrement their next_index
            self.next_index[src] -= 1
        else:
            # ... but if they match, update their next_index
            self.next_index[src] = replica_commit_index + 1

            # If the replica's log is up to date, increment our ack_count
            if self.last_applied + 1 <= replica_commit_index:
                self.ack_count += 1

            # If over half our replicas have committed an entry...
            if self.ack_count > len(self.replicas) + 1:
                # ... apply that entry to our local db and reset ack_count
                entry = self.log[self.last_applied]
                self.key_store[entry['key']] = entry['value']
                self.last_applied += 1
                self.ack_count = 0
                self.send_message(entry['client'], 'ok', entry['value'], entry['MID'])

        return

    def get(self, client, key, MID):
        if key in self.key_store:
            value = self.key_store[key]
        else:
            value = ''
        self.send_message(client, 'ok', value, MID)
        print self.id + '     Getting value: ' + str(value)
        return

    def put(self, client, key, value, MID):
        self.log.append({
            'key': key,
            'value': value,
            'term': self.term,
            'client': client,
            'MID': MID
        })
        self.commit_index += 1
        self.ack_count += 1
        print self.id + '     I just logged ' + str(self.log[len(self.log) - 1])
        return

    def update_log(self, entries, prev_log_index, prev_log_term, term, leader_commit_index):
        identical_logs = True

        # Reply false if the heartbeat term is less than our term (1)
        if term < self.term:
            identical_logs = False
            self.send_message(self.leader, 'ack', {'identical_logs': identical_logs, 'commit_index': self.commit_index})
            print self.id + '     FALSE - inconsistent logs '
            return

        # If our log is empty...
        if len(self.log) == 0:
            for entry in entries:
                # ... add the entries from our leader to our log
                self.log.append({'key': entry['key'], 'value': entry['value'], 'term': entry['term']})
                print self.id + '     I just logged ' + str(entry['value'])

        # If our prev_log_index is in range of our current log... (2)
        elif prev_log_index <= len(self.log):
            # ... and the terms match up... (2)
            if self.log[prev_log_index - 1]['term'] == prev_log_term:
                # ... add all new entries to log (4)
                # (3)
                i = 0

                for entry in entries:
                    # If we are trying to add an entry with the same index as an existing entry but different term...
                    if len(self.log) > prev_log_index + i:
                        if self.log[prev_log_index + i]['term'] != entry['term']:
                            # ... delete that entry and everything following
                            self.log = self.log[:prev_log_index + i]
                            print self.id + '     I just deleted some stuff from my log'

                    # Otherwise, add it to our log
                    else:
                        self.log.append({'key': entry['key'], 'value': entry['value'], 'term': entry['term']})
                        print self.id + '     I just logged ' + str(entry['value'])

                    i += 1

            # If the terms don't match up, then our logs are fucked
            else:
                identical_logs = False
                print self.id + '     FALSE - inconsistent logs (they fucked)'

        # Update our commit_index to be the length of our current log
        self.commit_index = len(self.log)

        # (5)
        if leader_commit_index > self.commit_index:
            self.commit_index = min(leader_commit_index, len(self.log))

        self.send_message(self.leader, 'ack', {'identical_logs': identical_logs, 'commit_index': self.commit_index})
        return

    def update_keystore(self, leader_last_applied):
        if leader_last_applied > self.last_applied and len(self.log) > self.last_applied:
            for entry in self.log[self.last_applied - 1:]:
                self.key_store[entry['key']] = entry['value']
                self.last_applied += 1
                print self.id + '     I just applied ' + str(entry['value'])

        # self.send_message(self.leader, 'ack', {'identical_logs': True, 'commit_index': self.commit_index})

        return

    def receive_messages(self):
        msg_raw = self.sock.recv(32768)

        if len(msg_raw) == 0:
           return

        print self.id + '     ' + msg_raw
        print ''
        msg = json.loads(msg_raw)
        self.messages.append(msg)
        return

    def handle_messages(self):
        while len(self.messages) > 0:
            msg = self.messages.pop(0)

            if 'term' in msg:
                self.check_leadership(msg['src'], msg['leader'], msg['term'], msg['type'])

            # If I am the leader...
            if self.state == 'leader':
                if msg['type'] == 'get':
                    self.get(msg['src'], msg['key'], msg['MID'])
                    # TODO ; if a get() fails, send a 'fail'

                elif msg['type'] == 'put':
                    # TODO ; if a put() fails, send a 'fail' and retry

                    self.put(msg['src'], msg['key'], msg['value'], msg['MID'])
                elif msg['type'] == 'ack':
                    self.handle_ack(msg['src'], msg['identical_logs'], msg['commit_index'])

            # We are not the leader but...
            else:
                # ... we got a heartbeat message
                if msg['type'] == 'append_entries':
                    self.handle_heartbeat(
                        msg['entries'],
                        msg['prev_log_index'],
                        msg['prev_log_term'],
                        msg['term'],
                        msg['leader_commit_index'],
                        msg['leader_last_applied']
                    )

                # ... we received a get() or put() request...
                elif msg['type'] in ['get', 'put']:
                    # ... redirect it to the leader
                    print self.id + '     Redirecting client to leader...'
                    self.send_message(msg['src'], 'redirect', MID=msg['MID'])

                # ... or if we are asked to cast a vote
                elif msg['type'] == 'req_vote':
                    if self.state == 'follower' and msg['term'] > self.term:
                        self.cast_vote(msg['src'], msg['term'])

                # ... or if someone casts a vote for us
                elif msg['type'] == 'cast_vote' and self.state == 'candidate':
                    print"{0}    I got a vote from {1} woohoo lets handle it!".format(self.id, msg['src'])
                    self.handle_vote(msg['src'])

        return
    
    def listen(self):
        while True:
            ready = select.select([self.sock], [], [], 0.1)[0]
            if self.sock in ready:
                self.receive_messages()

            self.handle_messages()

            clock = time.time()

            # If I am a follower and I haven't heard from the leader for the length of timeout, try to elect myself
            if self.state == 'follower' and clock - self.last_leader_msg >= self.timeout:
                print "{0}     Haven't heard from our leader, timeout".format(self.id)
                self.request_vote()

            # If an election lasts longer than our election timeout, try to re-elect myself
            # "split vote"
            if self.state == 'candidate' and clock - self.election_start_time >= self.election_timeout:
                print "{0}     SPLIT VOTE TIMEOUT".format(self.id)
                print self.id + "     " + "split vote timeout " + str(clock - self.election_start_time)
                self.request_vote()

            # If I haven't sent a heartbeat in awhile, send one
            if self.state == 'leader' and clock - self.last_heartbeat_sent >= self.heartbeat_timeout:
                self.send_heartbeat()

        return

if __name__ == "__main__":
    init_id = sys.argv[1]
    init_replica_ids = sys.argv[2:]

    db = KVStore(init_id, init_replica_ids)
    db.listen()
