#!/usr/bin/env python

import sys, socket, select, time, json, random

class KVStore:
    def __init__(self, id, replicas):
        # Socket connection
        self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
        # Message buffer
        self.messages = []
        # Timeout in milliseconds
        self.timeout = random.randint(150, 300) / float(1000)
        # Timeout to be used during a split vote
        self.election_timeout = random.randint(50, 125) / float(1000)
        # Time between heartbeat messages (in seconds)
        self.heartbeat_timeout = .1
        # Instance ID number
        self.id = id
        # The ID numbers of all the other replicas
        self.replicas = replicas
        # The current election term across all replicas
        self.term = 0
        # A list of dictionaries containing a command, the term it was called, and a log index
        self.log = []
        # Dict containing key value pairs as requested by the client
        self.key_store = {}
        # Index of the last thing I committed
        self.commit_index = 0
        # Index of the last thing committed to the state machine
        self.last_applied = 0
        # Dict { replica_id: next_index } representing the next log entry to send for each replica
        self.next_index = {}
        # List of indexes of the highest log entry known to be replicated on each replica
        self.match_index = []
        # Needs to be one of the following: follower, candidate, leader
        self.state = 'follower'
        # Counter for the number of messages sent
        self.MID = 0
        # List of replica IDs of those who have voted for me to be elected
        self.votes = []
        # ID of our current leader
        self.leader = 'FFFF'
        # Time we last heard a message from the leader
        self.last_leader_msg = time.time()
        # Time that the most recent election I was a candidate for started
        self.election_start_time = ''
        # Time I sent the last heartbeat message
        self.last_heartbeat_sent = time.time()

        # Connect to the network. All messages to/from other replicas and clients will occur over this socket
        self.sock.connect(self.id)

    # init election process by changing state to candidate, incrementing term and sending elect msgs to replicas
    def request_vote(self):
        print "{0}     requesting votes, term {1}".format(self.id, self.term)
        # wipe out any old votes before starting a new election
        self.leader = 'FFFF'
        self.votes = [self.id] # vote for urself tho
        self.state = 'candidate'
        self.term += 1
        self.send_message('FFFF', 'req_vote')
        self.election_start_time = time.time()
        return

    def cast_vote(self, ID, term):
        print "{0}     casting vote for {1}, term {2}".format(self.id, ID, self.term)
        self.term = term
        self.leader = 'FFFF'
        self.send_message(ID, 'cast_vote')
        self.last_leader_msg = time.time()
        return

    def handle_vote(self, src):
        # if the sender has not voted for me yet, add the vote to my list of votes
        if src not in self.votes:
            self.votes.append(str(src))
            print "{0}     {1} voted for me".format(self.id, src)

        # if majority voted for me
        if len(self.votes) > (len(self.replicas) / 2) + 1:
            print "{0}     I am elected, term {1}".format(self.id, self.term)
            # we are the leader!
            self.leader = self.id
            self.state = 'leader'

            for replica in self.replicas:
                self.next_index[replica] = len(self.log) + 1

            # Tell everyone I'm the BOSS
            self.send_heartbeat()

        print "{0}     votes: {1}".format(self.id, self.votes)
        return

    def send_message(self, dest, type, value={}):
        """
        Sends a message over the socket to the dst with the given parameters
        :param dst: Message destination
        :param type: One of the following
            get: Read request from client
            put: Update store with given value from client
            redirect: Forward put or get request to leader
            noop:
            req_vote: For candidates to request votes from replicas
            cast_vote: Send a vote for a candidate to that candidate
        """

        msg = {
                'src': self.id,
                'dst': dest,
                'leader': self.leader,
                'type': type,
                'MID': self.id + str(self.MID),
                'term': self.term
            }

        if type == 'append_entries':
            prev_log_index = self.next_index[dest] - 1

            msg.update({
                'entry_to_add': self.log[prev_log_index],  # sus but shorthand
                'prev_log_index': prev_log_index,
                'prev_log_term': self.log[prev_log_index - 1]['term'],
                'leader_commit': self.commit_index
            })

        elif type == 'ok':
            msg.update({'value': value})

        elif type == 'ack':
            msg.update({'identical_logs': value})

        self.MID += 1
        #print json.dumps(msg)
        self.sock.send(json.dumps(msg))
        return

    def send_heartbeat(self):
        # TODO ; send multiple log entries to append to boost efficiency
        for replica in self.replicas:
            self.send_message(replica, 'append_entries')

        self.last_heartbeat_sent = time.time()

    def receive_messages(self, ready):
        msg_raw = self.sock.recv(32768)

        if len(msg_raw) == 0:
           return

        print self.id + '     ' + msg_raw
        msg = json.loads(msg_raw)
        self.messages.append(msg)
        return

    def check_leadership(self, msg_source, msg_leader, msg_term):
        # If we receive a message with a higher term...
        if msg_source == msg_leader and msg_term >= self.term:
            # If we are the leader...
            if self.state == 'leader':
                # ... make that replica our leader
                self.leader = msg_source

            # Update our term and state
            self.term = msg_term
            self.state = 'follower'
        return


    def get(self, src, key):
        if key in self.key_store:
            value = self.key_store[key]
        else:
            value = ''

        self.send_message(src, 'ok', value)
        return

    def put(self, key, value, term):
        self.log.append({'key': key, 'value': value, 'term': term})
        # should we immediately send a heartbeat every time we update? NO
        return

    def handle_heartbeat(self, entry, prev_log_index, prev_log_term, term, leader_commit):
        identical_logs = True
        self.last_leader_msg = time.time()

        # Reply false if the heartbeat term is less than our term (1)
        if term < self.term:
            identical_logs = False
            self.send_message(self.leader, 'ack', identical_logs)
            return

        # If our prev_log_index is in range of our current log... (2)
        if prev_log_index <= len(self.log):
            # ... and the terms match up... (2)
            if self.log[prev_log_index - 1]['term'] == prev_log_term:
                i = 0
                # ... add all new entries to log (4)
                # (3)
                if len(self.log) > prev_log_index + i and self.log[prev_log_index + i]['term'] == entry['term']:
                    self.log.append({'key': entry['key'], 'value': entry['value'], 'term': entry['term']})
                # Delete the existing entry and all that follow
                else:
                    self.log = self.log[0 : prev_log_index + i]

                i += 1

            else:
                identical_logs = False

        # (5)
        if leader_commit > self.commit_index:
            self.commit_index = min(leader_commit, len(self.log))

        self.send_message(self.leader, 'ack', identical_logs)
        self.last_leader_msg = time.time()
        return

    def handle_messages(self):
        while len(self.messages) > 0:
            msg = self.messages.pop(0)
            self.check_leadership(msg['src'], msg['leader'], msg['term'])

            # If I am the leader...
            if self.state == 'leader':
                if msg['type'] == 'get':

                    self.get(msg['src'], msg['key'])

                    # TODO ; if get() is successful, send an 'ok' with value
                    # TODO ; if a get() fails, send a 'fail'

                elif msg['type'] == 'put':
                    # TODO ; if put() is successful, send an 'ok'
                    # TODO ; if a put() fails, send a 'fail' and retry
                    # TODO ; if a put() is sent to a follower, respond w/ a redirect and fwd to leader
                    self.put(msg['key'], msg['value'], msg['term'])
                    print 'doing put stuff'
                elif msg['type'] == 'ack':
                    # If a replica's log isn't identical to mine (leader's), decrement their next_index
                    if not msg['identical_logs']:
                        self.next_index[msg['src']] -= 1

            # If I'm not the leader and I receive a get() or put() request...
            elif msg['type'] in ['get', 'put']:
                # ... redirect it to the leader
                self.send_message(self.leader, 'redirect')

            # We are not the leader but...
            else:
                # If we got a heartbeat message
                if msg['type'] == 'append_entries':
                    self.handle_heartbeat(
                        msg['entry_to_add'],
                        msg['prev_log_index'],
                        msg['prev_log_term'],
                        msg['term'],
                        msg['leader_commit']
                    )

                # If we are asked to cast a vote
                elif msg['type'] == 'req_vote':
                    if self.state == 'follower' and msg['term'] > self.term:
                        self.cast_vote(msg['src'], msg['term'])

                # If someone casts a vote for us
                elif msg['type'] == 'cast_vote' and self.state == 'candidate':
                    print"{0}    I got a vote from {1} woohoo lets handle it!".format(self.id, msg['src'])
                    self.handle_vote(msg['src'])

            # Handle noop messages. This may be removed from your final implementation
            #elif msg['type'] == 'noop':
                #print '%s received a NOOP from %s' % (msg['dst'], msg['src'])
    
    def listen(self):
        last = 0

        while True:
            ready = select.select([self.sock], [], [], 0.1)[0]
            if self.sock in ready:
                self.receive_messages(ready)

            self.handle_messages()

            clock = time.time()
            '''if self.state == 'candidate':
                print self.id + "     " + "time since split vote timeout " + str(clock - self.election_start_time)
                print self.id + "     " + "split vote timeout " + str(self.election_timeout)'''

            # If I am a follower and I haven't heard from the leader for the length of timeout, try to elect myself
            if self.state == 'follower' and clock - self.last_leader_msg >= self.timeout:
                #print self.id + "     " + "time passed since we heard from leader" + str(clock - self.lastLeaderMsg)
                #print self.id + "     " + "timeout " + str(self.timeout)
                print "{0}     Havent heard from our leader, timeout".format(self.id)
                self.request_vote()

            # If an election lasts longer than our election timeout, try to re-elect myself
            # "split vote"
            if self.state == 'candidate' and clock - self.election_start_time >= self.election_timeout:
                print "{0}     SPLIT VOTE TIMEOUT".format(self.id)
                print self.id + "     " + "split vote timeout " + str(clock - self.election_start_time)
                self.request_vote()

            # If I haven't sent a heartbeat in awhile, send one
            if self.state == 'leader' and clock - self.last_heartbeat_sent >= self.heartbeat_timeout:
                self.send_heartbeat()

            '''if clock-last > 2:
                # Send a no-op message to a random peer every two seconds, just for fun
                # You definitely want to remove this from your implementation
                msg = {'src': self.id, 'dst': random.choice(self.replicas), 'leader': 'FFFF', 'type': 'noop'}
                self.sock.send(json.dumps(msg))
                #print '%s sending a NOOP to %s' % (msg['src'], msg['dst'])
                last = clock'''


if __name__ == "__main__":
    init_id = sys.argv[1]
    init_replica_ids = sys.argv[2:]

    db = KVStore(init_id, init_replica_ids)
    db.listen()
