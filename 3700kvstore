#!/usr/bin/env python

import sys, socket, select, time, json, random

class KVStore:
	def __init__(self, id, replicas):
		# Socket connection
		self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
		# Timeout in milliseconds
		self.timeout = random.randint(150, 300) / float(1000)
		# Timeout to be used during a split vote
		self.election_timeout = random.randint(50, 100) / float(1000)
		# Instance ID number
		self.id = id
		# The ID numbers of all the other replicas
		self.replicas = replicas
		# The current election term across all replicas
		self.term = 0
		# Needs to be one of the following: follower, candidate, leader
		self.state = 'follower'
		# Time we last heard a message from the leader
		self.lastLeaderMsg = time.time()
		# Counter for the number of messages sent
		self.MID = 0
		# ID of the last leader we voted for
		self.last_vote = ''
		# List of replica IDs of those who have voted for me to be elected
		self.votes = []
		# ID of our current leader
		self.leader = 'FFFF'
		# Time that the most recent election I was a candidate for started
		self.election_start_time = ''

		# Connect to the network. All messages to/from other replicas and clients will occur over this socket
		self.sock.connect(self.id)

	# init election process by changing state to candidate, incrementing term and sending elect msgs to replicas
	def request_vote(self):
		self.state = 'candidate'
		self.term += 1
		self.send_message('FFFF', 'req_vote')
		self.election_start_time = time.time()

	def cast_vote(self, ID):
		self.last_vote = ID
		self.send_message(ID, 'cast_vote')

	def handle_vote(self, src):
		if src not in self.votes:
			self.votes.append(src)

		if len(self.votes) > (len(self.replicas) / 2) + 1:
			self.leader = self.id

		self.send_message('FFFF', 'noop')

	def send_message(self, dst, type):
		"""
		Sends a message over the socket to the dst with the given parameters
		:param dst: Message destination
		:param type: One of the following
			get: Read request from client
			put: Update store with given value from client
			redirect: Forward put or get request to leader
			noop:
			req_vote: For candidates to request votes from replicas
			cast_vote: Send a vote for a candidate to that candidate
		"""
		msg = {'src': self.id, 'dst': dst, 'leader': self.leader, 'type': type, 'MID': self.id + str(self.MID), 'term': self.term}
		self.MID += 1
		self.sock.send(json.dumps(msg))

	def listen(self):
		last = 0

		while True:
			ready = select.select([self.sock], [], [], 0.1)[0]

			if self.sock in ready:
				msg_raw = self.sock.recv(32768)

				if len(msg_raw) == 0: continue
				msg = json.loads(msg_raw)

				# If we receive a message with a higher term...
				if msg['term'] > self.term:
					# If we are the leader...
					if self.leader == self.id:
						# ... make that replica our leader
						self.leader = msg['src']
					else:
						# ... otherwise, update our term
						self.term = msg['term']

				# For now, ignore get() and put() from clients
				if msg['type'] in ['get', 'put']:
					print('type: ' + msg['type'])

				# If we are asked to cast a vote
				elif msg['type'] == 'req_vote':
					if self.state == 'follower':
						if self.last_vote == '':
							self.cast_vote(msg['src'])
							#								 TODO ; reset when leader has been elected

				# If someone casts a vote for us
				elif msg['type'] == 'cast_vote':
					self.handle_vote(msg['src'])

				# Handle noop messages. This may be removed from your final implementation
				elif msg['type'] == 'noop':
					print '%s received a NOOP from %s' % (msg['dst'], msg['src'])


			clock = time.time()

			# If we haven't heard from the leader for the length of timeout, try to elect myself
			if clock - self.lastLeaderMsg >= self.timeout:
				self.request_vote()

			# If an election lasts longer than our election timeout, try to relect myself
			if self.state == 'candidate' and clock - self.election_start_time >= self.election_timeout:
				# TODO ; ....
				continue

			if clock-last > 2:
				# Send a no-op message to a random peer every two seconds, just for fun
				# You definitely want to remove this from your implementation
				msg = {'src': self.id, 'dst': random.choice(self.replicas), 'leader': 'FFFF', 'type': 'noop'}
				self.sock.send(json.dumps(msg))
				print '%s sending a NOOP to %s' % (msg['src'], msg['dst'])
				last = clock


if __name__ == "__main__":
	init_id = sys.argv[1]
	init_replica_ids = sys.argv[2:]

	db = KVStore(init_id, init_replica_ids)
	db.listen()
